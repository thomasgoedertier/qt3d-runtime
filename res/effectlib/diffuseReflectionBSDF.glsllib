#include "funcdiffuseReflectionBSDF.glsllib"
#include "funcdiffuseReflectionWrapBSDF.glsllib"

vec4 lambertReflectionBSDF( in vec3 N, in vec3 L, in vec3 lightDiffuse )
{
  // If we're not going to use the roughness on the diffuse, there's no point
  // in wasting the cycles for the branching.
  float cosThetaI = max( 0.0f, dot( N, L ) );
  return vec4( cosThetaI * lightDiffuse, 1.0f );
}

vec4 diffuseReflectionBSDFEnvironment( in vec3 N, in float roughness )
{
  return( vec4( 0.0f, 0.0f, 0.0f, 1.0f ) );
}

// RNM radiosity normal maps
vec4 diffuseRNM( in vec3 N, in vec3 rnmX, in vec3 rnmY, in vec3 rnmZ )
{
  // we use a fixed basis like Half Life
  vec3 B0 = vec3( -0.40825, 0.70711, 0.57735);
  vec3 B1 = vec3( -0.40825, -0.70711, 0.57735);
  vec3 B2 = vec3( 0.8165, 0.0, 0.57735);

  vec3 dp;
  dp.x = clamp( dot ( N , B0 ), 0.0, 1.0);
  dp.y = clamp( dot ( N , B1 ), 0.0, 1.0);
  dp.z = clamp( dot ( N , B2 ), 0.0, 1.0);

  float sum = 1.0 / dot( dp, vec3(1.0, 1.0, 1.0) );
  vec3 diffuseLight = dp.x * rnmX + dp.y * rnmY + dp.z * rnmZ;
  //vec3 diffuseLight = N.x * rnmX + N.y * rnmY + N.z * rnmZ;

  return (vec4(diffuseLight, 1.0) * sum);
}
